LEGEND
  - todo; + in progress; * done; / obsolete, do not want, or can't repro
  ? open question; . note; bug: marks bugs.

- How could I support re-exports?
  . I guess if I see 'module Xyz' in the export list, I should go get the tags
    from Xyz.
  . To be accurate, I'd want only the imported tags.
  . And of course we can also export just by writing the symbol name.
  . So the fully accurate version would be look at the export list.  Any
    symbols imported from someplace else have to be chased to that module.
  . This is actually two things:
    1 - one is to only make tags for exported symbols.  I'd want to emit those
      as qualified tags, and the rest as static tags.  However, I don't know
      that this really helps, because it's not like having too many qualified
      tags hurts anything, since by nature they won't conflict.  You're just
      unlikely to follow them.
      . The problem with this is that it can get messed up by my
        #ifdef TESTING export all habit.  Let's not do 1 then.
    2 - The other thing is to be able to chase imported symbols.  Possibly
      recurse multiple times.
  . If I do 2, I still have to do full parsing of the export and import
    blocks:
      exports = parseExports module :: [Either Symbol ModuleName]
      imports = parseImports module :: Map ModuleName (Either [Symbol] All)
      imports = [either id (exportsOf module) imports | (module, imports) <- imports]
      exportsOf = parse module

      resolve (Right module) = chase module (Map.lookup module imports)
      resolve (Left sym) = chase module [sym]
      in
      resolve exports
    . So this seems doable, but nontrivial.
  . First I should see what the haskell ide guys have done.

* Implement --fully_qualified
  . This is like --qualified except that it uses full qualification, for use
    with qualified_tag.py.

- Is \ continuation in strings is parsed correctly?

* I'll need to sort them again.  Why not just pay no mind to sorting except to
  a full sort as the last step?  I think 100k elements should sort quickly.
  . Time old and new versions against ghc source.
  . Do emacs tags need to be sorted?  Apparently not.

* I get scrambled warning output, probably due to threads not locking the
output.

/ Lots of parse errors on ghc source.
  . Looks like it's just weird primitive syntax like data (a, b) = (a, b).

* Implement --qualified flag.
  . The only reason to have static is that the same name is prioritized if
    local.  But with qualified names, none are local.  No wait, I still have
    all the unqualified ones for local jumping.  But vim already knows the
    filename, so won't it already prioritize that?  Yes, it will.
  . Verify that local definitions get priority.  They do.
  * Write vim binding to bind to ^] and expand to keyword + '.', without
    having to modify iskeyword.
    . Problems with adding '.' to iskeyword:
      . 'w' is unexpected, so I'm surprised when cw deletes past the '.'.
      . * and # also include the qualification, which means I can't check
        spelling with * and search highlighting.  It also breaks my habit of
        finding a definition by doing *, switching to its file, then n.  But
        maybe I should be using tags for that!

* Option to collapse different typed tags on the same line.  Didn't I add
something like this long ago?
  - I think I can get rid of RepeatedTag now, but I should probably implement
    merging for emacs tags.

- Would it make a difference to use Vector for tags instead of lists?
